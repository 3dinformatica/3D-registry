{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "util-categorize-schema-fields",
  "type": "registry:lib",
  "title": "Schema Fields Utility",
  "description": "A utility functions to categorize schema fields by their data type, returning an object with the fields grouped by type and returning the default values for the fields. Useful for dynamic form generation and schema analysis.",
  "dependencies": [
    "zod"
  ],
  "files": [
    {
      "path": "registry/lib/utils/util-categorize-schema-fields/util-categorize-schema-fields.ts",
      "content": "/**\n * Categorizes Zod schema fields by their data type.\n * Useful for dynamic form generation and schema analysis.\n */\n\nimport {\n  ZodArray,\n  ZodBoolean,\n  ZodEnum,\n  ZodNullable,\n  ZodNumber,\n  ZodObject,\n  ZodOptional,\n  ZodString,\n} from \"zod\";\nimport type { z } from \"zod\";\n\n// ============================== EXPORTED TYPES ==============================\n\n/**\n * Extracts the string keys from a type.\n */\nexport type StringKeyOf<TData> = Extract<keyof TData, string>;\n\n/**\n * Schema fields grouped by type.\n*/\nexport type SchemaFieldsByType<T extends z.ZodTypeAny> = {\n  uuid: Array<StringKeyOf<z.infer<T>>>;\n  string: Array<StringKeyOf<z.infer<T>>>;\n  number: Array<StringKeyOf<z.infer<T>>>;\n  datetime: Array<StringKeyOf<z.infer<T>>>;\n  boolean: Array<StringKeyOf<z.infer<T>>>;\n  enum: Array<StringKeyOf<z.infer<T>>>;\n  arrayString: Array<StringKeyOf<z.infer<T>>>;\n  arrayEnum: Array<StringKeyOf<z.infer<T>>>;\n  arrayDatetime: Array<StringKeyOf<z.infer<T>>>;\n  arrayUuid: Array<StringKeyOf<z.infer<T>>>;\n  arrayNumber: Array<StringKeyOf<z.infer<T>>>;\n};\n\n/**\n * Schema fields grouped by type, including excluded fields.\n * The `excluded` array contains all field keys that were explicitly excluded\n * from categorization via the `excludedKeysList` option.\n */\nexport type SchemaFieldsByTypeWithExcluded<T extends z.ZodTypeAny> =\n  SchemaFieldsByType<T> & {\n    excluded: Array<StringKeyOf<z.infer<T>>>;\n  };\n\n// ============================== INTERFACES ==============================\n\ninterface CategorizeSchemaFieldsProps<T extends z.ZodTypeAny> {\n  schema: T;\n  excludedKeysList?: Array<StringKeyOf<z.infer<T>>>;\n  withExcluded?: boolean;\n}\n\ninterface UnwrappedOptionalNullable {\n  unwrapped: z.ZodTypeAny;\n  isOptional: boolean;\n  isNullable: boolean;\n}\n\n// ============================== HELPER FUNCTIONS ==============================\n\n/**\n * Unwraps optional and nullable wrappers from a Zod field.\n * Returns the unwrapped field and flags indicating if it was optional/nullable.\n */\nfunction unwrapOptionalNullable(field: z.ZodTypeAny): UnwrappedOptionalNullable {\n  let unwrapped = field;\n  let isOptional = false;\n  let isNullable = false;\n\n  while (unwrapped instanceof ZodOptional || unwrapped instanceof ZodNullable) {\n    if (unwrapped instanceof ZodOptional) {\n      isOptional = true;\n    }\n    if (unwrapped instanceof ZodNullable) {\n      isNullable = true;\n    }\n    unwrapped = unwrapped.unwrap() as z.ZodTypeAny;\n  }\n\n  return { unwrapped, isOptional, isNullable };\n}\n\n/**\n * Gets a field from a ZodObject schema by key.\n * Returns undefined if schema is not a ZodObject or field doesn't exist.\n */\nfunction getSchemaField<T extends z.ZodTypeAny>(\n  schema: T,\n  fieldName: string,\n): z.ZodTypeAny | undefined {\n  if (!(schema instanceof ZodObject)) {\n    console.log(\"schema is not a ZodObject\");\n    return undefined;\n  }\n\n  const field = schema.shape[fieldName as keyof typeof schema.shape];\n  return field;\n}\n\n/**\n * Gets the default value for a Zod type (after unwrapping).\n * Does not handle optional/nullable - those should be unwrapped first.\n */\nfunction getDefaultValueByZodType(field: z.ZodTypeAny): any {\n  // Handle arrays\n  if (field instanceof ZodArray) {\n    return [];\n  }\n\n  // Handle primitive types\n  if (field instanceof ZodString) {\n    return \"\";\n  } else if (field instanceof ZodNumber) {\n    return 0;\n  } else if (field instanceof ZodBoolean) {\n    return undefined;\n  } else if (field instanceof ZodEnum) {\n    // Return the first enum value as default, or null if no values\n    // In Zod v4, use the public .options property instead of _def.values\n    const enumValues = field.options;\n    return enumValues && enumValues.length > 0 ? enumValues[0] : null;\n  }\n\n  // For other types (objects, etc.), return undefined\n  return undefined;\n}\n\n// ============================== EXPORTED FUNCTIONS ==============================\n\n/**\n * Categorizes schema fields by their Zod type (uuid, string, number, datetime, boolean, enum, and their array variants).\n * When `withExcluded` is true, also includes an `excluded` array containing all keys that were excluded from categorization.\n */\nexport function categorizeSchemaFields<T extends z.ZodTypeAny>(\n  props: CategorizeSchemaFieldsProps<T>,\n): SchemaFieldsByType<T> | SchemaFieldsByTypeWithExcluded<T> {\n  const { schema, excludedKeysList, withExcluded = false } = props;\n\n  const excludeKeys = excludedKeysList ?? [];\n  const schemaShape = schema instanceof ZodObject ? schema.shape : schema;\n  const schemaKeys = Object.keys(schemaShape);\n\n  const filteredKeys = schemaKeys.filter(\n    (key) => !excludeKeys.includes(key as StringKeyOf<z.infer<T>>),\n  ) as Array<StringKeyOf<z.infer<T>>>;\n\n  const fieldsByType: SchemaFieldsByType<T> = {\n    uuid: [],\n    string: [],\n    number: [],\n    datetime: [],\n    boolean: [],\n    enum: [],\n    arrayString: [],\n    arrayEnum: [],\n    arrayDatetime: [],\n    arrayUuid: [],\n    arrayNumber: [],\n  };\n\n  filteredKeys.forEach((key) => {\n    const field = schemaShape[key as keyof typeof schemaShape];\n    const { unwrapped: unwrappedField } = unwrapOptionalNullable(field);\n\n    // Handle arrays by checking the inner element type\n    if (unwrappedField instanceof ZodArray) {\n      // In Zod v4, use the public .element property instead of _def.type\n      const { unwrapped: innerType } = unwrapOptionalNullable(\n        unwrappedField.element as z.ZodTypeAny,\n      );\n\n      if (innerType instanceof ZodString) {\n        // In Zod v4, use .def.checks (public API) and check .format property instead of .kind\n        const isDatetime = innerType.def.checks?.some(\n          (check: any) => check.format === \"datetime\",\n        ) ?? false;\n        const isUUID = innerType.def.checks?.some(\n          (check: any) => check.format === \"uuid\",\n        ) ?? false;\n\n        if (isDatetime) {\n          fieldsByType.arrayDatetime.push(key);\n        } else if (isUUID) {\n          fieldsByType.arrayUuid.push(key);\n        } else {\n          fieldsByType.arrayString.push(key);\n        }\n      } else if (innerType instanceof ZodEnum) {\n        fieldsByType.arrayEnum.push(key);\n      } else if (innerType instanceof ZodNumber) {\n        fieldsByType.arrayNumber.push(key);\n      }\n      // Arrays of other types are not categorized\n      return;\n    }\n\n    // Handle primitive types\n    if (unwrappedField instanceof ZodNumber) {\n      fieldsByType.number.push(key);\n    } else if (unwrappedField instanceof ZodBoolean) {\n      fieldsByType.boolean.push(key);\n    } else if (unwrappedField instanceof ZodEnum) {\n      fieldsByType.enum.push(key);\n    } else if (unwrappedField instanceof ZodString) {\n      // In Zod v4, use .def.checks (public API) and check .format property instead of .kind\n      const isDatetime = unwrappedField.def.checks?.some(\n        (check: any) => check.format === \"datetime\",\n      ) ?? false;\n      const isUUID = unwrappedField.def.checks?.some(\n        (check: any) => check.format === \"uuid\",\n      ) ?? false;\n\n      if (isDatetime) {\n        fieldsByType.datetime.push(key);\n      } else if (isUUID) {\n        fieldsByType.uuid.push(key);\n      } else {\n        fieldsByType.string.push(key);\n      }\n    }\n  });\n\n  console.log(\n    \"fieldsByType: \",\n    JSON.stringify(\n      withExcluded\n        ? { ...fieldsByType, excluded: excludedKeysList ?? [] }\n        : fieldsByType,\n      null,\n      2,\n    ),\n  );\n\n  return withExcluded\n    ? { ...fieldsByType, excluded: excludedKeysList ?? [] }\n    : fieldsByType;\n}\n\n/**\n * Helper to check if a field belongs to a specific category.\n * Useful for component selection based on field type.\n *\n * @example\n * ```ts\n * const fields = categorizeSchemaFields({ schema });\n * if (isFieldOfType(fields, 'enum', 'status')) {\n *   return <FormItemComboBoxEnum ... />\n * }\n * ```\n */\nexport function isFieldOfType<T extends z.ZodTypeAny>(\n  fields: SchemaFieldsByType<T> | SchemaFieldsByTypeWithExcluded<T>,\n  category: keyof SchemaFieldsByType<T> | \"excluded\",\n  fieldName: string,\n): boolean {\n  const fieldArray = fields[category as keyof typeof fields];\n\n  const isPresent = fieldArray.includes(fieldName as StringKeyOf<z.infer<T>>);\n  console.log(`${fieldName} is inside category ${category}: `, isPresent);\n  return isPresent;\n}\n\n/**\n * Helper to get the category type of a specific field.\n * Returns the first matching category or null if not found.\n * Note: This will return 'excluded' if the field was in the excludedKeysList and withExcluded was true.\n *\n * @example\n * ```ts\n * const fields = categorizeSchemaFields({ schema });\n * const fieldType = getFieldType(fields, 'status');\n * // Returns: 'enum' | 'uuid' | 'string' | ... | 'excluded' | null\n * ```\n */\nexport function getFieldType<T extends z.ZodTypeAny>(\n  fields: SchemaFieldsByType<T> | SchemaFieldsByTypeWithExcluded<T>,\n  fieldName: string,\n): keyof SchemaFieldsByType<T> | \"excluded\" | null {\n  for (const [category, fieldNames] of Object.entries(fields)) {\n    if (fieldNames.includes(fieldName as StringKeyOf<z.infer<T>>)) {\n      console.log(`${fieldName} is of type ${category}`);\n      return category as keyof SchemaFieldsByType<T> | \"excluded\";\n    }\n  }\n  console.log(`${fieldName} is not found in the schema`);\n  return null;\n}\n\n/**\n * Gets the default value for a specific field in a Zod schema based on its type.\n * Handles optional/nullable fields by returning undefined.\n *\n * @example\n * ```ts\n * const defaultValue = getDefaultValueByField(mySchema, 'status');\n * // Returns: '' | 0 | false | [] | null | undefined based on field type\n * ```\n */\nexport function getDefaultValueByField<T extends z.ZodTypeAny>(\n  schema: T,\n  fieldName: string,\n): any {\n  const field = getSchemaField(schema, fieldName);\n  if (!field) {\n    console.log(`field ${fieldName} not found in schema`);\n    return undefined;\n  }\n\n  const { unwrapped } = unwrapOptionalNullable(field);\n  const defaultValue = getDefaultValueByZodType(unwrapped);\n  console.log(\n    `defaultValue of ${fieldName}:`,\n    JSON.stringify(defaultValue, null, 2),\n  );\n\n  return defaultValue;\n}\n\n/**\n * Gets default values for all fields in a Zod schema based on their types.\n * Returns a record where keys are field names and values are their defaults.\n *\n * @example\n * ```ts\n * const defaults = getDefaultValuesBySchema(mySchema);\n * // Returns: { name: '', age: 0, isActive: false, tags: [], ... }\n * ```\n */\nexport function getDefaultValuesBySchema<T extends z.ZodTypeAny>(\n  schema: T,\n): Record<string, any> {\n  if (!(schema instanceof ZodObject)) {\n    return {};\n  }\n\n  const defaults: Record<string, any> = {};\n  const schemaShape = schema.shape;\n  const schemaKeys = Object.keys(schemaShape);\n\n  schemaKeys.forEach((key) => {\n    const defaultValue = getDefaultValueByField(schema, key);\n    defaults[key] = defaultValue;\n  });\n\n  return defaults;\n}\n",
      "type": "registry:lib",
      "target": "lib/utils/util-categorize-schema-fields.ts"
    }
  ]
}